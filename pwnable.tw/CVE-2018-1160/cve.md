Đầu tiên xem lại source code của [Netatalk 3.1.11](https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11/)

Tại `dsi_opensess.c`: 
```c
void dsi_opensession(DSI *dsi)
{
  uint32_t i = 0; /* this serves double duty. it must be 4-bytes long */
  int offs;

  if (setnonblock(dsi->socket, 1) < 0) {
      LOG(log_error, logtype_dsi, "dsi_opensession: setnonblock: %s", strerror(errno));
      AFP_PANIC("setnonblock error");
  }

  /* parse options */
  while (i < dsi->cmdlen) {
    switch (dsi->commands[i++]) {
    case DSIOPT_ATTNQUANT:
      memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
      dsi->attn_quantum = ntohl(dsi->attn_quantum);

    case DSIOPT_SERVQUANT: /* just ignore these */
    default:
      i += dsi->commands[i] + 1; /* forward past length tag + length */
      break;
    }
  }

  /* let the client know the server quantum. we don't use the
   * max server quantum due to a bug in appleshare client 3.8.6. */
  dsi->header.dsi_flags = DSIFL_REPLY;
  dsi->header.dsi_data.dsi_code = 0;
  /* dsi->header.dsi_command = DSIFUNC_OPEN;*/

  dsi->cmdlen = 2 * (2 + sizeof(i)); /* length of data. dsi_send uses it. */

  /* DSI Option Server Request Quantum */
  dsi->commands[0] = DSIOPT_SERVQUANT;
  dsi->commands[1] = sizeof(i);
  i = htonl(( dsi->server_quantum < DSI_SERVQUANT_MIN || 
	      dsi->server_quantum > DSI_SERVQUANT_MAX ) ? 
	    DSI_SERVQUANT_DEF : dsi->server_quantum);
  memcpy(dsi->commands + 2, &i, sizeof(i));

  /* AFP replaycache size option */
  offs = 2 + sizeof(i);
  dsi->commands[offs] = DSIOPT_REPLCSIZE;
  dsi->commands[offs+1] = sizeof(i);
  i = htonl(REPLAYCACHE_SIZE);
  memcpy(dsi->commands + offs + 2, &i, sizeof(i));
  dsi_send(dsi);
}
```

Nhìn qua thì có vẻ không có gì, nhưng tại phần comment `parse option`:
```c
  while (i < dsi->cmdlen) {
    switch (dsi->commands[i++]) {
    case DSIOPT_ATTNQUANT:
      memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
      dsi->attn_quantum = ntohl(dsi->attn_quantum);

    case DSIOPT_SERVQUANT: /* just ignore these */
    default:
      i += dsi->commands[i] + 1; /* forward past length tag + length */
      break;
    }
  }
```
![image](https://github.com/vuhz/CTF/assets/90823042/127530e9-bdf7-4abe-bff8-b244ac5f9a9c)

Nhưng ở phần `memcpy`, chương trình không có check lại độ dài trước khi thực hiện, mà `dsi->attn_quantum` là **uint32_t** -> 4 byte integer và `dsi->commands` có thể bị điều khiển bởi attacker.
Bên trong argument của `memcpy`, có hai arg mà attacker có thể điểu khiển đó là `dsi->commands + i + 1` (source) và `dsi->commands[i]` (size). và `dsi->commands` là **char array** nên giá trị max của nó là 255.

Tại struct `DSI` ở `include/libatalk/dsi.h`:
```c
typedef struct DSI {
    struct DSI *next;             /* multiple listening addresses */
    AFPObj   *AFPobj;
    int      statuslen;
    char     status[1400];
    char     *signature;
    struct dsi_block        header;
    struct sockaddr_storage server, client;
    struct itimerval        timer;
    int      tickle;            /* tickle count */
    int      in_write;          /* in the middle of writing multiple packets,
                                   signal handlers can't write to the socket */
    int      msg_request;       /* pending message to the client */
    int      down_request;      /* pending SIGUSR1 down in 5 mn */

    uint32_t attn_quantum, datasize, server_quantum;
    uint16_t serverID, clientID;
    uint8_t  *commands; /* DSI recieve buffer */
    uint8_t  data[DSI_DATASIZ];    /* DSI reply buffer */
    size_t   datalen, cmdlen;
    off_t    read_count, write_count;
    uint32_t flags;             /* DSI flags like DSI_SLEEPING, DSI_DISCONNECTED */
    int      socket;            /* AFP session socket */
    int      serversock;        /* listening socket */

    /* DSI readahead buffer used for buffered reads in dsi_peek */
    size_t   dsireadbuf;        /* size of the DSI readahead buffer used in dsi_peek() */
    char     *buffer;           /* buffer start */
    char     *start;            /* current buffer head */
    char     *eof;              /* end of currently used buffer */
    char     *end;

#ifdef USE_ZEROCONF
    char *bonjourname;      /* server name as UTF8 maxlen MAXINSTANCENAMELEN */
    int zeroconf_registered;
#endif

    /* protocol specific open/close, send/receive
     * send/receive fill in the header and use dsi->commands.
     * write/read just write/read data */
    pid_t  (*proto_open)(struct DSI *);
    void   (*proto_close)(struct DSI *);
} DSI;
```

`DSI->commands` là pointer, và ở parse option nó xử lí command ở một chuỗi liền nhau, cấu trúc của nó sẽ trông như sau:
```
*command:
+---------------------------++---------------------------++-------------+
|  type_1  | size_1 | cmd_1 ||  type_2  | size_2 | cmd_2 || 	...	|
+---------------------------++---------------------------++-------------+
^  1 byte  ^ 1 byte ^	     ^	1 byte  ^ 1 byte ^

```
và jump qua từng command bằng
```c
    default:
      i += dsi->commands[i] + 1; /* forward past length tag + length */
      break;
```

\> Chúng ta có thể overwrite lần lượt **datasize**, **server_quantum**, **serverID**, **clientID**, **\*commands** và một phần của **data** chỉ với 1 byte size có thể control.

Cấu trúc của DSI header sẽ trông như sau:

![5-4231761600](https://github.com/vuhz/CTF/assets/90823042/2187bc82-139c-4fa7-9bb5-25c1859b18d9)
<details>
<summary>Chi tiết</summary>
	
- **Flags**: Nó quyết định xem packet đó là **request** hay là **reply**
	
- **Command**: OpenSession command (1 trong 7 commands)
  
- **Request ID**: Để xác định ở request và được copy lại vào reply
  
- **Error code/Enclosed Data Offset**: Dành cho error code của reply. Nếu nó là request packet, nó sẽ được đặt về 0 trừ khi dùng cho `DSI Write command`
  
- **Total Data Length**: Length của payload
  
- **Reserved**: Để cho tương lai
  
- **Payload**: Chứa **DSI data** hoặc **AFP packet**
</details>

Và ta có thể build request như sau:
```py
dsi_payload = "\x01" # Server Request Quantum
dsi_payload += "\x04" # Option Size
dsi_payload += "\x00\x00\x40\x00" # Client Quantumdsi_packet = "\x00" # Request flag

dsi_packet = "\x04" # DSIOpenSession command
dsi_packet += "\x41\x41" # Request ID
dsi_packet += "\x00\x00\x00\x00" # Error code, not set by client
dsi_packet += struct.pack(">I", len(dsi_payload)) # Length of payload
dsi_packet += "\x00\x00\x00\x00" # Reserved for future usedsi_packet += dsi_payload
```
